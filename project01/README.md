#01
- 프로젝트 관리시스템 환영 메시지 출력
  "PMS에 오신 걸 환영합니다."

#02
- 다음과 같이 회원 정보를 입력 받아 출력하라!
이름? 홍길동
이름은 홍길동입니다.

#03
- 다음과 같이 회원 정보를 입력 받아 출력하라!
이름? 홍길동
이메일? hong@test.com
암호? 1111
전화? 111-1111
------------------------
홍길동, hong@test.com, 1111, 111-1111

#04
- 값 객체(Value Object)를 이용하여 입력 받은 회원정보를 저장하라.  
  동작은 버전 03과 같다.
- 사용 문법:
  => Value Object(사용자 정의 데이터 타입) 클래스의 선언.
     예) Member 클래스  

#05
- 다섯 명의 회원 정보를 입력 받아 출력하라
- 사용 문법:
  => 레퍼런스 배열을 이용하여 여러 인스턴스의 주소를 저장
  => 반복문 활용

#06
- 회원 정보를 입력한 후 저장할 것인 지 여부를 물어본다.
이름? 홍길동
이메일? hong@test.com
암호? 1111
전화? 111-1111
저장하시겠습니까?(y/n) y
저장하였습니다.
저장하시겠습니까?(y/n) N
저장을 취소하였습니다.
저장하시겠습니까?(y/n) x
잘못된 명령어입니다.
저장하시겠습니까?(y/n)
------------------------
(출력은 기존과 동일하다)
- 사용 문법:
  => 조건문 활용
  => 문자열을 대문자 또는 소문자로 변환하는 방법

#07
- 회원 정보 입력 회수를 다섯 개로 고정하지 않는다.
- 사용자에게 계속 입력할 지 물어서 결정한다.
이름? 홍길동
이메일? hong@test.com
암호? 1111
전화? 111-1111
저장하시겠습니까?(y/n) y
저장하였습니다.
계속입력하시겠습니까?(y/n) y
....
계속입력하시겠습니까?(y/n) n
------------------------------
(지금까지 입력한 내용을 출력한다.)
- 사용 문법
  => 레퍼런스 배열과 입력 개수를 센다.

#08
- 사용자로부터 저장 여부 또는 계속 입력 여부를 묻는 코드를
  다음의 메서드로 분리하라.
  => static boolean confirm(String message) {}
  => message : 프롬프트에 출력하는 문자열
  예) confirm("저장하시겠습니까?");
      저장하시겠습니까?(y/n)
  예) confirm("계속하시겠습니까?");
      계속하시겠습니까?(y/n)
- 사용 문법:
  => 메서드 정의 및 호출
  => 파라미터의 활용
  => 리턴 값을 활용

#09
- 명령어에 따라 회원 정보를 다룰 수 있도록 변경하라.
명령> add
이름? 홍길동
이메일? hong@test.com
암호? 1111
전화? 111-1111
저장하시겠습니까?(y/n) y
저장하였습니다.
저장하시겠습니까?(y/n) N
저장을 취소하였습니다.
명령> list
0, 홍길동, hong@test.com, 1111, 1111-2222
1, 홍길동, hong@test.com, 1111, 1111-2222
2, 홍길동, hong@test.com, 1111, 1111-2222
3, 홍길동, hong@test.com, 1111, 1111-2222
명령> delete
삭제할 회원의 번호는? 2
정말로 삭제하시겠습니까?(y/n) y
삭제하였습니다.
정말로 삭제하시겠습니까?(y/n) n
삭제를 취소하였습니다.
명령> list
0, 홍길동, hong@test.com, 1111, 1111-2222
1, 홍길동, hong@test.com, 1111, 1111-2222
2,
3, 홍길동, hong@test.com, 1111, 1111-2222
명령> update
변경할 회원 번호는? 1
이름(홍길동)? 임꺽정
이메일(hong@test.com)? leem@test.com
암호(1111)? 1112
전화(1111-2222)? 1111-1234
변경하시겠습니까?(y/n) y
변경하였습니다.
변경하시겠습니까?(y/n) n
변경을 취소하였습니다.
명령> list
0, 홍길동, hong@test.com, 1111, 1111-2222
1, 임꺽정, leem@test.com, 1112, 1111-1234
2,
3, 홍길동, hong@test.com, 1111, 1111-2222
명령> quit
안녕히 가세요!
명령> xxx
올바르지 않은 명령어입니다.
명령>
- 사용 문법:
  => 반복문과 조건문의 활용

#10
- 각 명령어(add,update,list,delete,quit,기타)를 처리하는 코드를
  별도의 메서드로 분리하라.
- 사용 문법:
  => 메서드 정의 및 호출 --> 재사용할 수 있는 코드로 만들자!

#11
- 멤버 정보를 다루는 메서드를 별도의 클래스로 분류한다.
- 사용 문법:
  => 클래스 정의
  => 인스턴스 필드와 인스턴스 멤버

#12
- 프로젝트 정보를 등록, 목록조회, 변경, 삭제하는 기능을 추가한다.
- 사용 문법:
  => 클래스 정의
  => 여러 클래스의 인스턴스를 다루는 방법

#13
- 프로젝트 정보 또는 회원 정보를 등록할 때 개수에 제한을 두지 않게 한다.
- 사용문법:
  => Linked List 도입
  => java01/src/algorithm/ex01/ 의 LinkedList와 Bucket 클래스를 사용한다.
- MemberController와 ProjectController에 적용한다.  

#14
- 제네릭을 적용한 LinkedList를 사용하여 회원 정보 및 프로젝트 정보를 관리하라!
- 사용문법:
  => Generic을 적용한 LinkedList
  => java01/src/algorithm/ex04/ 의 LinkedList와 Bucket 클래스를 사용한다.

#15
- LinkedList에 예외 적용.
- 사용문법:
  => try ~ catch ~
  => throw ~

#16
- Bucket 클래스를 LinkedList의 중첩 클래스로 만든다.
- 왜? Bucket은 LinkedList에서만 사용하기 때문이다.

#17
- ArrayList 클래스를 적용하라!

#18
- 사용자 입력한 데이터를 Stream API를 사용하여 저장하고 로딩하라.

#19
- 메뉴를 처리하기 위해 호출하는 service() 메서드를 규칙으로 정의한다.
  => 향후 메뉴를 처리하는 모든 클래스는 이 인터페이스의 규칙에 따라 작성해야 한다.

#20
- 리플랙션(Reflection) API를 사용하여 메뉴 컨트롤러를 객체를 자동 생성하라!
  => 인스턴스 생성을 자동화시킨다.

#21
- High Cohesion OOP 설계 방법 적용
  => ProjectApp은 사용자에게 프롬프트를 출력하고 입력 받는 일도 하고,
     메뉴 처리기를 준비하는 일도 한다. 

#22
- 객체를 보관할 때 사용할 이름은 애노테이션으로부터 얻는다.
  => 애노테이션 적용!

#23
- 커맨드 패턴을 적용하여 명령어 당 한 개의 처리 클래스로 구성하라. 
예)
[이전 방식]
명령> go member
프로젝트관리> list

[변경 방식]
명령> member/list.do
.....
명령> member/add.do
.....

#24
- 여러 컨트롤러에 중복되어 있는 기능을 한 클래스로 만든다.
- Data를 처리하는 전문 클래스를 도입한다. 
  => "DAO"라 부른다. Data Access Object
  => Data Persistence 객체 
  
#25
- Information Expert 패턴에 따라 XxxDao 클래스가 데이터 처리를
  완전히 담당하게 개선하라!

#26
- 객체 공유와 의존 객체 주입(Dependency Injection) 적용

#27
- @RequestMapping 애노테이션을 추가한다.
  => 명령어를 처리하는 메서드를 지정한다.
  => MenuController 인터페이스가 필요없어 진다.
- XxxController는 MenuController 인터페이스를 구현하는 대신에
  @RequestMapping 애노테이션을 사용하여
  ProjectApp이 호출할 메서드를 지정한다.

#28
- 명령어를 처리하는 메서드(RequestHandler)의 파라미터 선언을 자유롭게 하도록 
  변경한다. 
- ProjectApp에서는 메서드를 호출하기 전에 파라미터를 분석하여 그에 맞는
  값을 준비해야 한다.  


#29 
- 여러 클래스에 분산되어 있는 CRUD(Create/Read/Update/Delete)관련 
  메서드를 한 클래스로 합친다.
- 반드시 합쳐야 하는 것은 아니다.
- 합치는 것이 유지보수에 낫다고 판단되면 합쳐라!
- 컨트롤러 클래스에 @RequestMapping 이 있다면, 메서드를 정보를 저장할 때
  클래스에 설정된 @RequestMapping 값과 합쳐서 명령어 정보를 저장하라!

#30
- XxxDao에 JDBC를 적용하라!

#31
- Connection 객체를 별도로 준비하여 DAO 객체에 주입하라!

#32
- 커넥션풀(ConnectionPool)을 적용하기
  => 사용할 때 마다 커넥션을 만들지 않는다.
  => 사용한 커넥션을 재활용하여 커넥션 생성을 줄인다.

#33
- persistence framework "mybatis" 적용
- 로그인 기능 추가
  => req-33.txt 파일 참조 








#
